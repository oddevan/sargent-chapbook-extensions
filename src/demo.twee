:: StoryTitle
Sargent Chapbook Extensions Demo



:: StoryData
{
    "ifid": "B90BF23F-A19F-4948-9299-6A9D36E6A434",
    "format": "Chapbook",
    "format-version": "2.0.0",
    "start": "Start"
}



:: StyleSheet [stylesheet]
code {
    font-size: 16px;
    background: #f1f3f5;
    padding-inline-start: 5px;
    padding-inline-end: 5px;
}
pre {
    display: block;
    font-size: 16px;
    margin: 0;
    padding-block-start: 1em;
    padding-block-end: 1em;
    padding-inline-start: 20px;
    padding-inline-end: 20px;
    background: #f1f3f5;
}
blockquote {
    display: block;
    margin: 0;
    padding-block-start: 1em;
    padding-block-end: 1em;
    padding-inline-start: 20px;
    padding-inline-end: 20px;
    background: #ebfbee;
}



:: Start
showText: false
hasKey: false
applesPicked: 1
--
{embed passage: '_Add All Text Manipulation'}

{embed passage: 'List of Extensions'}



:: List of Extensions
[cont]
## Sargent Chapbook Extensions Demo

Let's see the extensions in action!

> [[Text Collection]]
> [[Conditional Insert]]



:: Text Collection
_collectModifier: "[collect]"
_contModifier: "[cont]"
--
## Text Collection: Overview

The `[collect]` modifier collects text to be shown later or manipulated. All text that follows the modifier
is saved to be shown later using the insert <code>&lcub;show collected&rcub;</code>.

Let's try it out. Here's what the underlying code looks like:

<pre>
First, some regular text.

{_collectModifier}
If everything worked, _this_ text was collected!

{_contModifier}
Second, some more text.

Finally, let's show what we collected! &lcub;show collected&rcub;
</pre>

Here's what it looks like when Chapbook renders it.

<blockquote>
First, some regular text.

[collect]
If everything worked, _this_ text was collected!

[cont]
Second, some more text.

Finally, let's show what we collected! {show collected}
</blockquote>

That's all you need to know to use it, though we've got more advanced examples.

> [[Collecting more than one chunk of text->Collect Multiple Texts]]
> [[Resetting or modifying what's collected->Reset or Modify Text Collection]]
> [[Summary of all text collection capabilities->Text Collection Summary]]
> **[[Back to the list of extensions->List of Extensions]]**



:: Collect Multiple Texts
_collectModifier: "[collect]"
_collectNoSpaceModifier: "[collect no-space]"
_ifShowCollectModifier: "[if showText; collect]"
showText: !showText
--
## Text Collection: Multiple Texts

You can use `[collect]` more than once to keep adding to what you've collected. For this example, we'll
collect text by embedding multiple passages that have collects in them.

By default, `[collect]` puts a space between each new collection. If you're using it to build, say, a
description where you need to skip that space, you can use `[collect no-space]`.

We'll also show optional collection of text using an `[if]` modifier controlled by the `showText` variable.
_On this visit, `showText` is **{showText}**._

Here's the code in this passage:

<pre>
&lcub;embed passage: 'Collect 1'&rcub;
&lcub;embed passage: 'Collect 2'&rcub;
&lcub;embed passage: 'Collect 3'&rcub;

&lcub;show collected&rcub;
</pre>

The `Collect 1` passage contains:

<pre>
{_collectModifier}
The first embedded passage has a single section of text.
</pre>

The `Collect 2` passage contains:

<pre>
{_collectModifier}
The second embedded passage has an optional section controlled by an [if showText] modifier.
{_ifShowCollectModifier}
That modifier is true, so this optional section was collected.
</pre>

The `Collect 3` passage contains:

<pre>
{_collectNoSpaceModifier}
The third embedded passage used the {_collectNoSpaceModifier} modifier, so there's no space between
this sentence and the previous one.
</pre>

Here's how Chapbook renders all of that.

<blockquote>
{embed passage: 'Collect 1'}
{embed passage: 'Collect 2'}
{embed passage: 'Collect 3'}

{show collected}
</blockquote>


> [[Show this again, only this time with{if showText: 'out'} the conditional collection->Collect Multiple Texts]]
> [[Resetting or modifying what's collected->Reset or Modify Text Collection]]
> [[Summary of all text collection capabilities->Text Collection Summary]]
> **[[Back to the list of extensions->List of Extensions]]**



:: Collect 1
[collect]
The first embedded passage has a single section of text.



:: Collect 2
[collect]
The second embedded passage has an optional section controlled by an `[if showText]` modifier.
[if showText; collect]
That modifier is true, so this optional section was collected.



:: Collect 3
[collect no-space]
The third embedded passage used the `[collect no-space]` modifier, so there's no space between
this sentence and the previous one.



:: Reset or Modify Text Collection
_collectModifier: "[collect]"
_collectNewModifier: "[collect new]"
_contModifier: "[cont]"
_showCollectedKeepInsert: "{show collected, keep: true}"
_collectedVariableShow: "{__collected}"
__collected: ''
--
## Text Collection: Reset or Modify Text Collection

By default, `[collect]` adds to any text that's already been collected, and `&lcub;show collected&rcub;` empties the
collection so you can start over. You can change both of those behaviors.

`[collect new]` gets rid of all the previously-collected text and starts over.

<code>&lcub;show collected, keep: true&rcub;</code> shows the collected text without getting rid of it.

Finally, the collected text is stored in the Chapbook variable `__collected`. You can always work directly with that variable.

Let's try that out. Here's the code in this passage:

<pre>
At the start, `__collected` contains: {_collectedVariableShow}

{_collectModifier}
If this works, this text will be thrown away.

{_contModifier}
After the first collect, `__collected` contains: {_collectedVariableShow}

{_collectNewModifier}
This should be the only text that's collected.

{_contModifier}
After the second collect, `__collected` contains: {_collectedVariableShow}

Let's show the collection using the insert with `keep: true`: {_showCollectedKeepInsert}

After the insert with `keep: true`, `__collected` contains: {_collectedVariableShow}
</pre>

Here's how Chapbook renders it.

<blockquote>
At the start, <code>__collected</code> contains: {__collected}

[collect]
If this works, this text will be thrown away.

[cont]
After the first collect, `__collected` contains: {__collected}

[collect new]
This should be the only text that's collected.

[cont]
After the second collect, `__collected` contains: {__collected}

Let's show the collection using the insert with `keep: true`: {show collected, keep: true}

After the insert with `keep: true`, `__collected` contains: {__collected}
</blockquote>

> [[Collecting more than one chunk of text->Collect Multiple Texts]]
> [[Summary of all text collection capabilities->Text Collection Summary]]
> **[[Back to the list of extensions->List of Extensions]]**



:: Text Collection Summary
## Text Collection: Summary

### The Modifier

| Modifier | What it does |
| -------- | ------------ |
| `[collect]` | Collect the text that follows and **add it** to any already-collected text. |
| `[collect no-space]` | Collect the text that follows and add it to any already-collected text **with no space between them**. |
| `[collect new]` | Collect the text that follows, **replacing** any already-collected text. |

### The Insert

| Insert | What it does |
| ------ | ------------ |
| <code>&lcub;show collected&rcub;</code> | Show the collected text and **empty the collection**. |
| <code>&lcub;show collected, keep: true&rcub;</code> | Show the collected text and **keep the collection**. |

### Under the Hood

The collected text is kept in the `__collected` variable.

> [[Collecting more than one chunk of text->Collect Multiple Texts]]
> [[Resetting or modifying what's collected->Reset or Modify Text Collection]]
> **[[Back to the list of extensions->List of Extensions]]**



:: Conditional Insert
_ifInsert1: "{if hasKey: 'You could try [[unlocking it]].'}"
_ifInsert2: "{if hasKey: 'You could try [[unlocking it]].', else: 'You need a key.'}"
_ifInsert3: "{applesPicked} apple{if (applesPicked > 1): 's'}"
hasKey: !hasKey
applesPicked: applesPicked + 1
applesPicked (applesPicked > 2): 1
--
## Conditional Insert

### Showing Text When a Condition is True

The conditional insert is like the `[if]` conditional display modifier, except it's an insert
that you can use in the middle of other text.

In this passage, the variable `hasKey` is {hasKey}. The code:

<pre>
The door is locked. {_ifInsert1}
</pre>

produces the following:

<blockquote>
The door is locked. {if hasKey: 'You could try [[unlocking it]].'}
</blockquote>

### Showing Different Text When a Condition is False

You can also provide text to show if the condition evaluates to false. The code:

<pre>
The door is locked. {_ifInsert2}
</pre>

produces the following:

<blockquote>
The door is locked. {if hasKey: 'You could try [[unlocking it]].', else: 'You need a key.'}
</blockquote>

### Adding Text Without a Space

Where the conditional insert is especially useful is in adding a snippet of text onto another word.
In the following example, the variable `applesPicked` is {applesPicked}. The code:

<pre>
You pick {_ifInsert3}.
</pre>

produces the following:

<blockquote>
You pick {applesPicked} apple{if (applesPicked > 1): 's'}.
</blockquote>


> [[Show this again, only this time with different variable values->Conditional Insert]]
> **[[Back to the list of extensions->List of Extensions]]**



:: unlocking it

You unlocked the door!

> [[Return to the Conditional Insert example->Conditional Insert]]
> **[[Back to the list of extensions->List of Extensions]]**

